SQL Injection detection in python

Pattern 1,2 번에 대하여 어떤것을 써도 무방함.


#### Pattern 1 

###쿼리 매개변수

#GOOD EX

def is_admin(username: str) -> bool:
    with connection.cursor() as cursor:
        cursor.execute("""
            SELECT
                admin
            FROM
                users
            WHERE
                username = %(username)s
        """, {
            'username': username
        })
        result = cursor.fetchone()

    if result is None:
        # User does not exist
        return False

    admin, = result
    return admin


9행에서 이름이 지정된 매개변수 username을 사용하여 이동해야하는위치 예

11행에서 cursor.excute(). 연결은 username데이터 베이스에서 쿼리를 사용할때 사용

if username db
>>> is_admin('haki')
False
>>> is_admin('ran')
True
>>> is_admin('foo')
False
>>> is_admin("'; select true; --")
False



연결된 cursor.excute로 username db에 대한 문자열 처리

...    cursor.execute("""
...        SELECT
...            admin
...        FROM
...            users
...        WHERE
...            username = %(username)s
...    """, {
...        'username': "'; select true; --"
...    })
...    print(cursor.query.decode('utf-8'))
SELECT
    admin
FROM
    users
WHERE
    username = '''; select true; --'

아래 참조

###안전한 쿼리 매개변수 전달

#GOOD EX
cursor.execute("SELECT admin FROM users WHERE username = %s'", (username, ));
cursor.execute("SELECT admin FROM users WHERE username = %(username)s", {'username': username});







### 안전한 SQL 구성


from psycopg2 import sql

def count_rows(table_name: str, limit: int) -> int:
    with connection.cursor() as cursor:
        stmt = sql.SQL("""
            SELECT
                COUNT(*)
            FROM (
                SELECT
                    1
                FROM
                    {table_name}
                LIMIT
                    {limit}
            ) AS limit_query
        """).format(
            table_name = sql.Identifier(table_name),
            limit = sql.Literal(limit),
        )
        cursor.execute(stmt)
        result = cursor.fetchone()

    rowcount, = result
    return rowcount




구성을 완료한 뒤 
>>> count_rows('users', 1)
1
>>> count_rows('users', 10)
2

를 사용하여 조회 여부 확인

아래와 같이 트레이스백에서 psycopg 값을 이스케이프 하게 되면 UnderfinedTable예외가 발생하지 않고 보안적으로 안전하게 작동함.

>>> count_rows("(select 1) as foo; update users set admin = true where name = 'haki'; --", 1)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 18, in count_rows
psycopg2.errors.UndefinedTable: relation "(select 1) as foo; update users set admin = true where name = '" does not exist
LINE 8:                     "(select 1) as foo; update users set adm...
                            ^



https://realpython.com/prevent-python-sql-injection/ 참고




####pattern 2


urlpatterns = [
    # Route to code_execution
    url(r'^code-ex1$', code_execution_bad, name='code-execution-bad'),
    url(r'^code-ex2$', code_execution_good, name='code-execution-good')
]
 
def code_execution(request):
    if request.method == 'POST':
        first_name = base64.decodestring(request.POST.get('first_name', ''))
        #BAD -- Allow user to define code to be run.
        exec("setname('%s')" % first_name)
 
def code_execution(request):
    if request.method == 'POST':
        first_name = base64.decodestring(request.POST.get('first_name', ''))
        #GOOD --Call code directly
        setname(first_name)
		
		
		
		
입력되는 first_name 에 대한 값을 지정하여 쿼리조회 #BAD(잘못된 예) 에서는 db 조회 후 해당 first_name 과 일치 여부를 조회하게됨.
